function [P, sse, r_squared] = fit(SF, TF, R, min_xi, max_xi, options)
% FIT - Fit two-dimensional Gaussian function to a speed tuning data set.
%
%   [P, SSE, R_SQUARED] = vis.speed.fit(SF, TF, R, MIN_XI, MAX_XI, ...)
%
%   Fits a Gaussian to a set of responses generated by a speed tuning curve
%   using a robust multi-start optimization routine to find the best-fit
%   parameters.
%
%   Inputs:
%     SF      - An array of spatial frequency values.
%     TF      - An array of temporal frequency values.
%     R       - An array of measured responses.
%     MIN_XI  - The lower limit for the speed index ('xi') parameter. (Default: 0)
%     MAX_XI  - The upper limit for the speed index ('xi') parameter. (Default: 1)
%
%   Name-Value Pair Arguments:
%     numberStartPoints  - The number of initial starting points to try. (Default: 40)
%     SpecificStartPoint - A 7xN matrix specifying specific starting
%                          points to include in the search.
%
%   Outputs:
%     P         - A 7x1 vector with the best-fit parameters.
%     SSE       - The total sum of squared errors for the best fit.
%     R_SQUARED - The R-squared value (coefficient of determination).
%
%   Parameters (P):
%     [A, zeta, xi, sigma_sf, sigma_tf, sf0, tf0]
%
%   See also: vis.speed.fit_nospeed, lsqcurvefit
%

    arguments
        SF
        TF
        R
        min_xi (1,1) double = 0
        max_xi (1,1) double = 1
        options.numberStartPoints (1,1) double {mustBeInteger, mustBePositive} = 40
        options.SpecificStartPoint (7,:) double = []
    end

    SF = SF(:); TF = TF(:); R = R(:); % Ensure column vectors

    % --- Multi-start Optimization Setup ---
    % Define hard constraints (upper and lower bounds) for the fit parameters
    Upper = [2 * max(R); 3; max_xi; 4; 4; max(SF); max(TF)];
    Lower = [0; -3; min_xi; 0.1; 0.1; min(SF); min(TF)];

    StartPoint = zeros(7, options.numberStartPoints);

    for i = 1:options.numberStartPoints
        rule_idx = mod(i-1, 10) + 1;

        % Generate random components
        zeta_val = (Upper(2) - Lower(2)) * rand() + Lower(2);
        xi_val = (Upper(3) - Lower(3)) * rand() + Lower(3);
        sigma_sf_val = (Upper(4) - Lower(4)) * rand() + Lower(4);
        sigma_tf_val = (Upper(5) - Lower(5)) * rand() + Lower(5);

        % Rules based on the original StartPoint matrix structure
        % Multiplier for A is 0.2 * rule_idx
        % Multiplier for sf0 and tf0 is 0.1 * rule_idx

        A_val = (0.2 * rule_idx) * max(R);
        sf0_val = (0.1 * rule_idx) * max(SF);
        tf0_val = (0.1 * rule_idx) * max(TF);

        StartPoint(:, i) = [A_val; zeta_val; xi_val; sigma_sf_val; sigma_tf_val; sf0_val; tf0_val];
    end

    if ~isempty(options.SpecificStartPoint)
        StartPoint = [StartPoint, options.SpecificStartPoint];
    end

    % --- Fitting Loop ---
    optimal_error = Inf;
    P_optimal = [];
    opts = optimset('Display', 'off');

    for i = 1:size(StartPoint, 2)
        [P_current, error_current] = lsqcurvefit(@(P, SF) vis.speed.tuningfunc(SF, TF, P), StartPoint(:, i), SF, R, Lower, Upper, opts);
        if (error_current < optimal_error)
            optimal_error = error_current;
            P_optimal = P_current;
        end
    end

    P = P_optimal;
    sse = optimal_error;

    % --- Calculate Goodness of Fit ---
    sst = sum((R - mean(R)).^2);
    if sst == 0
        r_squared = 1;
    else
        r_squared = 1 - (sse / sst);
    end

end
