function [P, sse, r_squared] = fit(SF, TF, R, min_xi, max_xi)
% FIT - Fit two-dimensional Gaussian function to a speed tuning data set.
%
%   [P, SSE, R_SQUARED] = vis.speed.fit(SF, TF, R, MIN_XI, MAX_XI)
%
%   Fits a Gaussian to a set of responses generated by a speed tuning curve
%   using a robust multi-start optimization routine to find the best-fit
%   parameters.
%
%   Inputs:
%     SF      - An array of spatial frequency values.
%     TF      - An array of temporal frequency values.
%     R       - An array of measured responses.
%     MIN_XI  - The lower limit for the speed index ('xi') parameter. (Default: 0)
%     MAX_XI  - The upper limit for the speed index ('xi') parameter. (Default: 1)
%
%   Outputs:
%     P         - A 7x1 vector with the best-fit parameters.
%     SSE       - The total sum of squared errors for the best fit.
%     R_SQUARED - The R-squared value (coefficient of determination).
%
%   Parameters (P):
%     [A, zeta, xi, sigma_sf, sigma_tf, sf0, tf0]
%
%   See also: vis.speed.fit_nospeed, lsqcurvefit
%

% --- Input Validation and Defaults ---
if nargin < 4
    min_xi = 0;
end
if nargin < 5
    max_xi = 1;
end

SF = SF(:); TF = TF(:); R = R(:); % Ensure column vectors

% --- Multi-start Optimization Setup ---
% Define hard constraints (upper and lower bounds) for the fit parameters
Upper = [2 * max(R); 3; max_xi; 4; 4; max(SF); max(TF)];
Lower = [0; -3; min_xi; 0.1; 0.1; min(SF); min(TF)];

% Generate 10 systematic, semi-random starting points to thoroughly
% explore the parameter space.
zeta_rand = (Upper(2) - Lower(2)).*rand(10, 1) + Lower(2);
xi_rand = (Upper(3) - Lower(3)).*rand(10, 1) + Lower(3);
sigma_sf_rand = (Upper(4) - Lower(4)).*rand(10, 1) + Lower(4);
sigma_tf_rand = (Upper(5) - Lower(5)).*rand(10, 1) + Lower(5);

StartPoint = [[0.2 * max(R); zeta_rand(1); xi_rand(1); sigma_sf_rand(1); sigma_tf_rand(1); 0.1 * max(SF); 0.1 * max(TF)], ...
    [0.4 * max(R); zeta_rand(2); xi_rand(2); sigma_sf_rand(2); sigma_tf_rand(2); 0.2 * max(SF); 0.2 * max(TF)], ...
    [0.6 * max(R); zeta_rand(3); xi_rand(3); sigma_sf_rand(3); sigma_tf_rand(3); 0.3 * max(SF); 0.3 * max(TF)], ...
    [0.8 * max(R); zeta_rand(4); xi_rand(4); sigma_sf_rand(4); sigma_tf_rand(4); 0.4 * max(SF); 0.4 * max(TF)], ...
    [max(R); zeta_rand(5); xi_rand(5); sigma_sf_rand(5); sigma_tf_rand(5); 0.5 * max(SF); 0.5 * max(TF)], ...
    [1.2 * max(R); zeta_rand(6); xi_rand(6); sigma_sf_rand(6); sigma_tf_rand(6); 0.6 * max(SF); 0.6 * max(TF)], ...
    [1.4 * max(R); zeta_rand(7); xi_rand(7); sigma_sf_rand(7); sigma_tf_rand(7); 0.7 * max(SF); 0.7 * max(TF)], ...
    [1.6 * max(R); zeta_rand(8); xi_rand(8); sigma_sf_rand(8); sigma_tf_rand(8); 0.8 * max(SF); 0.8 * max(TF)], ...
    [1.8 * max(R); zeta_rand(9); xi_rand(9); sigma_sf_rand(9); sigma_tf_rand(9); 0.9 * max(SF); 0.9 * max(TF)], ...
    [2 * max(R); zeta_rand(10); xi_rand(10); sigma_sf_rand(10); sigma_tf_rand(10); max(SF); max(TF)]];

% --- Fitting Loop ---
optimal_error = Inf;
P_optimal = [];
opts = optimset('Display', 'off');

for i = 1:size(StartPoint, 2)
    [P_current, error_current] = lsqcurvefit(@(P, SF) vis.speed.tuningfunc(SF, TF, P), StartPoint(:, i), SF, R, Lower, Upper, opts);
    if (error_current < optimal_error)
        optimal_error = error_current;
        P_optimal = P_current;
    end
end

P = P_optimal;
sse = optimal_error;

% --- Calculate Goodness of Fit ---
sst = sum((R - mean(R)).^2);
if sst == 0
    r_squared = 1;
else
    r_squared = 1 - (sse / sst);
end

end
