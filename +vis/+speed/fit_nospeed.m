function [parameters,error] = fit_nospeed(sf,tf,r)
% SPEED.FIT.FIT_NOSPEED  Fit a two-dimensional Gaussian function without a
% speed parameter to data set.
%
%  [PARAMETERS,ERROR] = SPEED.FIT.FIT_NOSPEED(SF,TF,R)
%
%  Fits a Gaussian to a set of responses generated by a tuning curve
%  without a speed parameter.
%
%  Inputs:
%    SF is an array of spatial frequency values.
%
%    TF is an array of temporal frequency values.
%
%    R is an array of measured responses driven by the spatial and
%    temporal frequency values.
%
%  Outputs:
%    PARAMETERS is an array with parameters:
%    |-----------|-------------------------------|
%    | Parameter | Description                   |
%    |-----------|-------------------------------|
%    | A         | Peak response of the neuron   |
%    |...........|...............................|
%    | zeta      | Skew of the temporal          |
%    |           | frequency tuning curve        |
%    |...........|...............................|
%    | xi        | Speed parameter (set to 0)    |
%    |...........|...............................|
%    | sigma_sf  | Tuning width of the neuron    |
%    |           | for spatial frequency         |
%    |...........|...............................|
%    | sigma_tf  | Tuning width of the neuron    |
%    |           | for temporal frequency        |
%    |...........|...............................|
%    | sf0       | Preferred spatial frequency   |
%    |           | averaged across temporal      |
%    |           | frequencies                   |
%    |...........|...............................|
%    | tf0       | Preferred temporal frequency  |
%    |           | averaged across spatial       |
%    |           | frequencies                   |
%    |-----------|-------------------------------|
%
%    ERROR is the value of the squared 2-norm of the residual of the
%    model.
%
%  See also SPEED.FIT.COMPUTE.TUNINGFUNC, LSQCURVEFIT.
%
    random_starts = 10;

    sf = sf(:); tf = tf(:); r = r(:); % Make them column vectors

    % Define constraints on the fit
    A_low = 0; A_high = 2*max(r);
    A_initial = nan;

    zeta_low = -3; zeta_high = 3;
    zeta_initial = nan;

    xi_low = 0; xi_high = 0; % No speed parameter
    xi_initial = nan;

    sigma_sf_low = 0.1; sigma_sf_high = 4;
    sigma_sf_initial = nan;

    sigma_tf_low = 0.1; sigma_tf_high = 4;
    sigma_tf_initial = nan;

    sf0_low = min(sf); sf0_high = max(sf);
    sf0_initial = nan;

    tf0_low = min(tf); tf0_high = max(tf);
    tf0_initial = nan;

    Upper = [A_high; zeta_high; xi_high; sigma_sf_high; sigma_tf_high; sf0_high; tf0_high]; % The upper bounds
    Lower = [A_low; zeta_low; xi_low; sigma_sf_low; sigma_tf_low; sf0_low; tf0_low]; % The lower bounds

    % Use lsqcurvefit
    optimal_error = Inf; % The initial optimal error value, will be reduced later
    P_optimal = nan*ones(1,7); % Optimal P based on the various supplied starting points
    for i = 1:random_starts % Loop through the number of random starts
        A_start = A_initial;
        if isnan(A_initial) % If the initial value is Not a Number (NaN)
            A_start = A_low + rand*(A_high - A_low); % Randomly generate a starting value
        end

        zeta_start = zeta_initial;
        if isnan(zeta_initial)
            zeta_start = zeta_low + rand*(zeta_high - zeta_low);
        end

        xi_start = xi_initial;
        if isnan(xi_initial)
            xi_start = xi_low + rand*(xi_high - xi_low);
        end

        sigma_sf_start = sigma_sf_initial;
        if isnan(sigma_sf_initial)
            sigma_sf_start = sigma_sf_low + rand*(sigma_sf_high - sigma_sf_low);
        end

        sigma_tf_start = sigma_tf_initial;
        if isnan(sigma_tf_initial)
            sigma_tf_start = sigma_tf_low + rand*(sigma_tf_high - sigma_tf_low);
        end

        sf0_start = sf0_initial;
        if isnan(sf0_initial)
            sf0_start = sf0_low + rand*(sf0_high - sf0_low);
        end

        tf0_start = tf0_initial;
        if isnan(tf0_initial)
            tf0_start = tf0_low + rand*(tf0_high - tf0_low);
        end

        StartPoint = [A_start; zeta_start; xi_start; sigma_sf_start; sigma_tf_start; sf0_start; tf0_start];

        [parameters,error] = lsqcurvefit(@(P,SF) vis.speed.tuningfunc(SF,tf,P),StartPoint,sf,r,Lower,Upper);

        if (error < optimal_error) % If the error from the fit is lower than the current optimal error
            optimal_error = error; % Set the optimal error to the new error
            P_optimal = parameters; % Set the optimal P to be the fitted P with the lower error
        end
    end
    parameters = P_optimal; % Once the loop has finished, set P to be the most optimal fit
    error = optimal_error; % Once the loop has finished, select the most optimal error
